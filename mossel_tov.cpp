#include <stdlib.h>
#include <string>
#include <queue>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>

#define MOSSRESULTS "out"
#define PAGERESULTS "mossel_tov.html"

using namespace std;

struct Student {
	string student;
	bool queued;
	
	Student(string student, bool queued) {
		this->student = student;
		this->queued = queued;
	}

	bool operator ==(const Student &s2) {
		return student == s2.student;
	}
	bool operator ==(const string &s2) {
		return student == s2;
	}
};

struct Match {
	string student1;
	string student2;
	string url;
	string percent1;
	string percent2;
	string numIdentical;

	string hasStudent(const Student &s) {
		if (student1 == s.student)
			return student2;
		else if (student2 == s.student)
			return student1;
		else
			return "";
	}

};

bool sort_numIdentical(Match a, Match b) {
	return a.numIdentical < b.numIdentical;
}

vector<Match> getStudentMatches(vector<Match> matches, const Student &studentObj) {
	vector<Match> studentMatches;
	for (vector<Match>::iterator match_it = matches.begin(); match_it != matches.end(); match_it++) {
		if (match_it->hasStudent(studentObj) != "") //student exists, add match to collection
			studentMatches.push_back(*match_it);
	}

	sort(studentMatches.begin(), studentMatches.end(), sort_numIdentical);
	return studentMatches;
}


void genPage(vector<Match> matches, vector< vector<Student> > groups) {
	ofstream page;
	page.open(PAGERESULTS);
	if (!page.is_open()) {
		cerr << "Unable to write to " << PAGERESULTS << endl;
		exit(2);
	}

	page << "<html><head><title>Mossel Tov! - an grouping extension to the moss plagiarism detector</title><link rel=\"stylesheet\" type=\"text/css\" href=\"mossel_tov.css\"></head><body><table><tr><th></th><th> Matches with other Students <i>(# lines identical)</i></th></tr>";

	int i = 1;
	for (vector< vector<Student> >::iterator group_it = groups.begin(); group_it != groups.end(); group_it++, i++) {
		page << "<tr> <td colspan=\"2\" id=\"group_header\">Group " << i << "</td></tr>";
		for (vector<Student>::iterator stud_it = group_it->begin(); stud_it != group_it->end(); stud_it++) {
			vector<Match> studentMatches = getStudentMatches(matches, *stud_it);
			page << "<tr><td>" << stud_it->student << "</td><td>";
			for (vector<Match>::iterator match_it = studentMatches.begin(); match_it != studentMatches.end(); match_it++) {
				page << "<a href=\"http://moss.stanford.edu/results/" << match_it->url << "\">(" << match_it->hasStudent(*stud_it) << "," << match_it->numIdentical << ")</a> ";
			}
			page << "</td></tr>";
		}
	}
	page << "</table></body></html>";

	page.close();
}



int main(int argc, char **argv)
{
	//parse through moss results, delimit info by tabs
	system("./parseMoss.sh"); 
	ifstream mossresults;
	mossresults.open(MOSSRESULTS);
	if (!mossresults.is_open()) {
		cerr << "ERROR: Unable to read moss results file that was generated by parseMoss.sh" << endl;
		return 1;
	}

	vector<Match> matches; //matches collection
	vector<Student> students; //collection of all students
	string line;
	while (getline(mossresults, line)) {
		Match match;
		istringstream iss(line);
		getline(iss, match.url, '\t');
		getline(iss, match.student1, '\t');
		getline(iss, match.percent1, '\t');
		getline(iss, match.student2, '\t');
		getline(iss, match.percent2, '\t');
		getline(iss, match.numIdentical, '\t');
		Student s1(match.student1, false);
		Student s2(match.student2, false);

		//insert into student vector if new student
		vector<Student>::iterator s_it1 = find(students.begin(), students.end(), s1);
		if (s_it1 == students.end())
			students.push_back(s1);

		//insert into student vector if new student
		vector<Student>::iterator s_it2 = find(students.begin(), students.end(), s2);
		if (s_it2 == students.end())
			students.push_back(s2);

		matches.push_back(match);
	}

	mossresults.close();
	
	queue<Student> q; // Queue of students that are placed into a group
	vector< vector <Student> > groups;
	vector<Student> curGroup;

	/*Process:
	 * Start with a new (unqueued) student. This will be the first student
	 * in the current group. Find all students that have a match pair with
	 * this student based on MOSS results. For each student paired, add that 
	 * student to the current group and enqueue the student if not 
	 * already enqueued. Once the queue is empty, all the students 
	 * in the current group are related based on Moss results.*/

	for (vector<Student>::iterator student_it = students.begin(); student_it != students.end(); student_it++) {
		if (student_it->queued) //student already in queue or grouped 
			continue;

		student_it->queued = true;
		q.push(*student_it);
		curGroup.clear();

		while (!q.empty()) {
			Student studentObj = q.front();
			q.pop();
			curGroup.push_back(studentObj);
			for (vector<Match>::iterator match_it = matches.begin(); match_it != matches.end(); match_it++) {
				string student_matched = match_it->hasStudent(studentObj);
				if (student_matched != "") {
					//If 2nd student is new (not queued), add student to queue and to group
					vector<Student>::iterator s2_it;
					Student s(student_matched, false);
					s2_it = find(students.begin(), students.end(), s);
					if (!s2_it->queued) {
						s2_it->queued = true;
						q.push(*s2_it);
					}
				}
			}
		}

		groups.push_back(curGroup);
	}

	genPage(matches, groups);

	return 0;
}
